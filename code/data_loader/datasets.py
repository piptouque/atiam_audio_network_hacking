
import os
import re
from pathlib import Path
from typing import List, Tuple, Union, Callable, Any

import torch
import torch.nn as nn
import torchaudio

from torch.utils.data import Dataset
from torchvision.datasets.utils import download_url, extract_archive
from torchaudio.datasets import YESNO
from torchaudio.datasets.yesno import _RELEASE_CONFIGS as _YESNO_RELEASE_CONFIGS

from base import GenerativeModel

_VSCO2_RELEASE_CONFIGS = {
    "partial": {
        "folder_in_archive": "VSCO2_partial",
        "type": "zip",
        "url": "https://drive.google.com/file/d/1hd-WffTiNkhOdju4AvQcyQDKx406GxDW",
        "checksum": None
    },
    "hardcore": {
        "folder_in_archive": "VSCO2_hardcore",
        "type": "zip",
        "url": "https://drive.google.com/file/d/1QrbdogOgrmQ1WbYblxqxP78oZJpnI4j3",
        "checksum": None
    }
}


class VSCO2(Dataset):
    """Create a Dataset for VSCO2.
    Taken/Inspired by the YESNO dataset implementation: https://pytorch.org/audio/stable/_modules/torchaudio/datasets/yesno.html#YESNO

    Args:
        root (str or Path): Path to the directory where the dataset is found or downloaded.
        url (str, optional): The URL to download the dataset from.
        folder_in_archive (str, optional):
            The top-level directory of the dataset.
        download (bool, optional):
            Whether to download the dataset if it is not found at root path. (default: ``False``).
    """

    def __init__(
        self,
        root: Union[str, Path],
        transform: nn.Module = None,
        cfg=_VSCO2_RELEASE_CONFIGS["hardcore"],
        download: bool = False
    ) -> None:
        self.transform = transform
        self._parse_filesystem(root, cfg, download)

    def _parse_filesystem(self, root: str, cfg: dict, download: bool) -> None:
        """Inits instance from config

        Args:
            root (str): [description]
            cfg (dict): [description]
            download (bool): [description]

        Raises:
            RuntimeError: [description]
        """
        root = Path(root)
        folder_in_archive, url, checksum = cfg["folder_in_archive"], cfg["url"], cfg["checksum"]
        # archive_name = cfg["archive_name"]
        archive_name = os.path.basename(url + f'.{cfg["type"]}')
        archive_path = root / archive_name
        self._path = root / folder_in_archive
        if download:
            if not os.path.isdir(self._path):
                if not os.path.isfile(archive_path):
                    download_url(
                        url, root, filename=archive_name, md5=checksum)
                extract_archive(archive_path, self._path)

        if not os.path.isdir(self._path):
            raise RuntimeError(
                "Dataset not found. Please use `download=True` to download it."
            )

        file_paths = Path(self._path).rglob("*.wav")
        self._walker = sorted(file_paths)

    def _load_item(self, file_path: Path):
        labels = file_path.parent.as_posix().split(sep='/')
        # TODO: add key if it exists
        waveform, sample_rate = torchaudio.load(file_path.as_posix())
        audio = self.transform(
            waveform) if self.transform is not None else waveform
        return (audio, sample_rate), labels

    def __getitem__(self, n: int) -> Tuple[torch.Tensor, int, List[int]]:
        """Load the n-th sample from the dataset.

        Args:
            n (int): The index of the sample to be loaded

        Returns:
            (Tensor, int, List[int]): ``(waveform, sample_rate, labels)``
        """
        file_path = self._walker[n]
        item = self._load_item(file_path)
        return item

    def __len__(self) -> int:
        return len(self._walker)


class YESNOPacked(Dataset):
    """Same as YESNO but
    Interfaced the same as VSCO2 for compatibility.

    Args:
        Dataset ([type]): [description]
    """

    def __init__(
        self,
        root: Union[str, Path],
        transform: nn.Module = None,
        cfg=_YESNO_RELEASE_CONFIGS["release1"],
        download: bool = False
    ) -> None:
        self.transform = transform
        self.dataset = YESNO(
            root, cfg["url"], cfg["folder_in_archive"], download)

    def __getitem__(self, n: int) -> Tuple[torch.Tensor, int, List[int]]:
        """Load the n-th sample from the dataset.

        Args:
            n (int): The index of the sample to be loaded

        Returns:
            (Tensor, int, List[int]): ``(waveform, sample_rate, labels)``
        """
        waveform, sr, labels = self.dataset[n]
        audio = self.transform(
            waveform) if self.transform is not None else waveform

        return (audio, sr), labels

    def __len__(self) -> int:
        return len(self.dataset)


class GeneratedDataset(Dataset):
    """Data generated by a generative network (ex: VAE)

    Args:
        Dataset ([type]): [description]
    """

    def __init__(
        self,
        gen_model: GenerativeModel,
        nb_samples: int,
        label: int = 1
    ) -> None:
        self._gen_model = gen_model
        self._nb_samples = nb_samples
        self._label = label

    def __getitem__(self, n: int) -> Tuple[torch.Tensor, int, List[int]]:
        """Load the n-th sample from the dataset.
        Args:
            n (int): The index of the sample to be loaded

        Returns:
            (Tensor, int, List[int]): ``(waveform, sample_rate, labels)``
        """
        data = torch.flatten(self._gen_model.sample(1), start_dim=0, end_dim=1)
        return data, self._label

    def __len__(self) -> int:
        return self._nb_samples


class UntamperedDataset(Dataset):
    """Adversarial version of MNIST, labels all set to 1 (genuine)
    """

    def __init__(self, dataset: Dataset, label: int = 0) -> None:
        self._dataset = dataset
        self._label = label

    def __getitem__(self, n: int) -> Tuple[torch.Tensor, int, List[int]]:
        """Load the n-th sample from the dataset.
        Args:
            n (int): The index of the sample to be loaded

        Returns:
            (Tensor, int, List[int]): ``(waveform, sample_rate, labels)``
        """
        data, label = self._dataset[n]
        label = self._label
        return data, label

    def __len__(self) -> int:
        return len(self._dataset)
